// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

import (
	"runtime/internal/sys"
	"unsafe"
)

// Generational GC
//
// Go uses a sticky bit approach to implement generational
// GC. (See Alan Demers, Mark Weiser, Barry Hayes,
// Hans Boehm, Daniel Bobrow, and Scott Shenker. 1989.
// Combining generational and conservative garbage
// collection: framework and implementations. In
// Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on
// Principles of programming languages (POPL '90). ACM,
// New York, NY, USA, 261-269.
// DOI=http://dx.doi.org/10.1145/96709.96735 for the
// original reference.)
//
// Instead of "card marking" Go uses "card hashing" to
// identify regions that may contain pointers from
// mature to young objects. This approach has the advantage
// of eliminating the write barrier typically used to
// monitor the installation of mature to young pointers.
//
// Like similar systems we divide the heap into cards. Each
// card is a fixed number of bytes and given a heap address
// one can generate an index into a card table. Likewise an
// index in the card table can be used to locate the base
// of the card in the heap.
//
// Traditional card table entries hold a "mark". If
// a card is marked then it is possible that there is a
// pointer from a mature object to a young object in the
// card and the card must be scanned to locate and process
// such pointers. If unmarked no processing is required since
// the card is known not to contain a mature to young pointer.
//
// Traditional cards are marked by a write barrier that
// is invoked whenever a pointer is written into a card.
// The exact details are implementation specific but
// these classic mechanisms all use a write barrier of some
// sort.
//
// Go's card table entries hold a hash for each card.
// This hash is created by hashing all the heap pointers in
// the card. If a rehashing of the card produces the
// same hash then the card is considered unchanged.
// If on the other hand the hash changes from one GC cycle
// to the next cycle then the card is considered changed.
// The main advantage of this approach is that it does
// not need a write barrier so applications that do not
// benefit from a generation GC avoid the write barrier
// tax. For example applications that do few allocations
// and thus perform few  if any GCs can have a GC overhead
// that is much less than the overhead of a write barrier.
//
// The actual generational algorithm uses a traditional
// sticky bit approach as mentioned above. If the mark bit
// from the previous GC cycle is set the object survived the
// previous GC cycle and is considered mature. To
// promote an object one simply sets its mark bit.
//

const (
	gcGen      = true  // gcGen enables generational GC
	gcGenDebug = false // dump interesting debug information
)

// The hash generated by AES hash functions.
// 64 bits seems sufficient for our purposes here. However if there is a
// collision it could result in a reachable object being collected followed
// by undefined behavior.
// If further investigations suggest that we needed 128 bits, cardHash as
// well as the hashing calls need to be adjusted.
//
// There isn't the birthday problem so the chances of a collision
// are 1 in 2**64.
//
// Mean time between failures or MTBF is the important metric
// here. If it is significantly greater than other causes for failure
// then the risk is acceptable.
//
// Let's consider some conservative bounds.
// Assume Intel produces 400 million (4e8) chips a year. Assume they
// all run a Go program with a 10 GByte heap with 1 KBytes
// cards or 10e7 cards. Assume these chips executes
// a GC every second for a year (3.16e7 sec/year). We end up with
// 4e8 chips * 10e7 hashes/GC * 1 GC/sec * 3.16e7 sec/year = 1.26e23 hashes/year
// With a 64-bit hash, we expect
// 1.26e23 / 1.84e+19 = 6.847e3 or 6847 collisions/year.
// So for the 400 million chips there are 6847 failures in a year. That is a
// mean time to failure of 4e8/6.847e3 or 58,419 years. Assuming this
// math is correct and the assumptions reasonable then 64 bits is sufficient.
type cardHash uint64

// gen stores all state and statistics for generational GC.
// Hide all the generational GC values behind a variable called gen.
// Documentation for the fields are in the instantiation below.
var gen = struct {
	hashCardSeed      cardHash
	cycleCount        uint32
	forceFullGC       bool
	useMemhash        bool
	gcGenStats        bool
	spaceFull         bool
	warmupCount       uint32
	countBased        bool
	countBasedGen     bool
	cycleModulus      uint32
	highCostThreshold int
	cycleStats        cardStats
	totalStats        cardStats
}{
	hashCardSeed: cardHash(0), // Initialized to a random value.
	cycleCount:   0,           // count of GC cycles
	forceFullGC:  true,        // Force this cycle to do a full GC
	useMemhash:   false,       // true for HW/OSes without HW hashing, false for AMD64
	gcGenStats:   false,       // For experimental purpose this generates heap stats
	// After a full GC GOGC determines how much space is available for allocation. One necessary
	// but not sufficient condition for a generational GC to run is if less than half that
	// space survived the last GC. gen.spaceFull indicates if that space has been filled with
	// objects that survived the last GC.
	spaceFull: false,
	// The first warmupCount GCs are always full GCs.
	// TODO(rlh): warmup needs to be based on increasing heap size with a high
	// mark/cons ratio. Using a naive count of 4 until this can be fixed.
	warmupCount: 4,
	// if countBased is true and countBasedGen is true we do a full
	// GC when count % cycleModulus is 0
	// if countBased is true and countBasedGen is false we do a
	// generational when count % cycleModulus is 0
	// Use counting as the heuristic to determine if the cycle is a full
	// or generational cycle.
	countBased:    true,
	countBasedGen: true,
	cycleModulus:  2,
	// Avoid generational GC if cost of a full GC, as reported by
	// memstats.gc_cpu_fraction is < highGCCostThreshold.
	// The value is given as an int percent.
	highCostThreshold: 10,

	// Statistics and interesting characterizations of the heap are kept
	// in cycle specific as well as totals. Typically these are reported
	// if debug.gctrace>0.
	cycleStats: cardStats{},
	totalStats: cardStats{},
}

// For experiments and collecting of heap characterizations record
// various interesting values in a per cycle as well as a total.
type cardStats struct {
	hashedMatureObjects  uintptr // mature objects involved in hash
	unhashedYoungObjects uintptr // young objects not involved in hash
	hashedMatureBytes    uintptr // mature objects involved in hash
	unhashedYoungBytes   uintptr // young objects not involved in hash
	hashedCardsDiffers   uintptr // number of hashed cards where hash differs
	hashedCardsNodiffs   uintptr // number of hashed cards where hashes don't differ
	hashedBytesMarked    uintptr // number of hashed bytes where hash differs
	hashedBytesUnmarked  uintptr // number of hashed bytes where hashes don't differ
	scanCards            uintptr
	noScanCards          uintptr
	pointerCount         uintptr
	matureToYoung        uintptr
	matureToNil          uintptr
	matureToMature       uintptr
	ignoredCards         uintptr
}

// cardShard holds the information related to a shard
// of cards. These are added to mheap.shardedCardTable under the
// mheap lock when a new arena is added.
// See mheap.shardedCardTable.
type cardShard struct {
	cardHashes [cardsPerShard]cardHash // The hashes in this shard.
	shardBase  uintptr                 // pointer to where in the heap the first card starts
}

// isMature takes a span and an object index and returns true if
// the object at that index is marked and therefore mature because it
// survived the previous GC cycle.
// This function is only used during the mark phase of a generational
// cycle since it depends on the previous sweep ensuring the stickiness.
// of gcmarkBits.
func (s *mspan) isMature(objIndex uintptr) bool {
	if s.allocBits == nil {
		// new span created since start of GC so return false
		return false
	}
	bytep, mask := s.gcmarkBits.bitp(objIndex)
	return *bytep&mask != 0
}

// hashMatureCard returns the hash of the pointers in the mature
// objects found in the range [cardStart, cardEnd). This range
// must specify a single card and depends on the property that cards
// are contained in a single span.
func (s *mspan) hashMatureCard(cardStart, cardEnd uintptr) cardHash {
	hash := gen.hashCardSeed
	if s.allocBits == nil {
		return hash
	}
	if cardEnd > s.limit {
		// Do not consider info past the end of the span.
		// Cards can not overlap spans.
		cardEnd = s.limit
	}
	index := s.objIndex(cardStart)
	for objIndx, objStart := index, s.base()+index*s.elemsize; objStart < cardEnd; objIndx, objStart = objIndx+1, objStart+s.elemsize {
		if s.isMature(objIndx) {
			start := objStart
			end := objStart + s.elemsize
			if start < cardStart {
				start = cardStart
			}
			if end > cardEnd {
				end = cardEnd
			}
			hash = hashPointers(start, end, hash)
		}
	}
	return hash
}

// promoteMatureCardPtrs promotes all objects referenced from mature objects
// in the range [cardStart, cardEnd).
func (s *mspan) promoteMatureCardPtrs(cardStart, cardEnd uintptr) {
	if cardEnd > s.limit {
		// Do not consider info past the end of the span.
		// Cards can not overlap spans.
		cardEnd = s.limit
	}
	index := s.objIndex(cardStart)
	for objIndx, objStart := index, s.base()+index*s.elemsize; objStart < cardEnd; objIndx, objStart = objIndx+1, objStart+s.elemsize {
		if s.isMature(objIndx) {
			start := objStart
			end := objStart + s.elemsize
			if start < cardStart {
				start = cardStart
			}
			if end > cardEnd {
				end = cardEnd
			}
			// Pass at most one object at a time.
			transitivelyPromoteReferents(start, end)
		}
	}
}

// The block being hashed will be within a single object so once
// we see a no-more-pointers in the pointer bit map we can return the
// hash immediately. Since start may not be at the start of an object
// we need to be conservative and not check for the no-more-pointers
// in the first 2 slots.
func hashPointers(start, end uintptr, seed cardHash) cardHash {
	// pointer map.
	hbits := heapBitsForAddr(start)
	for slot := start; slot < end; slot += sys.PtrSize {
		// Find bits for this word.
		if slot != start {
			// Avoid needless hbits.next() on last iteration.
			hbits = hbits.next()
		}
		// Load bits once. See CL 22712 and issue 16973 for discussion.
		bits := hbits.bits()
		// During checkmarking, 1-word objects store the checkmark
		// in the type bit for the one word. The only one-word objects
		// are pointers, or else they'd be merged with other non-pointer
		// data into larger allocations.
		// start may not be to the start of an object so this is overly conservative
		// resulting in another harmless iteration.
		if slot != start && slot != start+1*sys.PtrSize && bits&bitScan == 0 {
			break // no more pointers in this object
		}
		if bits&bitPointer == 0 {
			continue // not a pointer
		}
		seed = cardHash(memhash64(unsafe.Pointer(slot), uintptr(seed)))
	}
	return seed
}

// Promote referents in between start and end. [start, end)
// is contained in a single object. Knowing that start is the
// only place an object can start is needed to properly parse the mark bits.
// If an object overlaps a card boundary then only promote referents between
// [start, end). Finally transitively promote all reachable
// young objects.
func transitivelyPromoteReferents(start, end uintptr) {
	// pointer map.
	hbits := heapBitsForAddr(start)
	for slot := start; slot < end; slot += sys.PtrSize {
		// Find bits for this word.
		if slot != start {
			// Avoid needless hbits.next() on last iteration.
			hbits = hbits.next()
		}
		// Load bits once. See CL 22712 and issue 16973 for discussion.
		bits := hbits.bits()
		// During checkmarking, 1-word objects store the checkmark
		// in the type bit for the one word. The only one-word objects
		// are pointers, or else they'd be merged with other non-pointer
		// data into larger allocations.
		// start may not be to the start of an object so this is overly conservative
		// resulting in another harmless iteration.
		if slot != start && slot != start+1*sys.PtrSize && bits&bitScan == 0 {
			break // no more pointers in this object
		}
		if bits&bitPointer == 0 {
			continue // this slot is not a pointer
		}
		// promote the referent.
		// Determine if the source object is a mature object.
		// Ignore slots that are not in mature objects since they may not be valid.
		// Furthermore they are uninteresting w.r.t. generational GC.
		obj := *(*uintptr)(unsafe.Pointer(slot))
		if !inheap(obj) {
			continue
		}
		mbits := markBitsForAddr(obj)
		if !mbits.isMarked() {
			shade(obj) // Transitively promote all reachable young object.
		}
	}
}

// processCardShard iterates through the cards in shard n.
// It hashes the pointers in each card in the shard and if the previous
// and the current hashes do not match then the card potentially contains
// a mature to young pointer. Look at each mature pointer and if it points
// to a young object then promote the young referent.
// nowritebarrier because gcDrain and gcDrainN are
// and it calls markroot is nowritebarrier
// and it calls markrootMature which is nowritebarrier
// and it calls processCardShard
// TODO(rlh): Considering using go:nowritebarrierrec instead
//go:nowritebarrier
func processCardShard(n int) {
	trace := false
	allArenaIndex := n / cardShardsPerArena
	if trace {
		println("allArenaIndex=", allArenaIndex, "n=", n, "cardShardsPerArena=", cardShardsPerArena)
	}
	arenaIndex := mheap_.allArenas[allArenaIndex]
	heapArena := mheap_.arenas[arenaIndex.l1()][arenaIndex.l2()]
	shardIndex := n % cardShardsPerArena
	if trace {
		println("arenaIndex.l1()=", arenaIndex.l1(), "arenaIndex.l2()=", arenaIndex.l2(),
			"len(mheap_.allArenas)=", len(mheap_.allArenas),
			"len(mheap_.arenas[arenaIndex.l1()]", len(mheap_.arenas[arenaIndex.l1()]),
			"mheap_.arenas[arenaIndex.l1()][arenaIndex.l2()]", mheap_.arenas[arenaIndex.l1()][arenaIndex.l2()])

		if heapArena == nil {
			println("!!! heapArena is nil")
		}
		println("shardIndex=", shardIndex, "heapArena=", heapArena)
		println("&heapArena.cardShards", &heapArena.cardShards)
	}
	shard := &heapArena.cardShards[shardIndex]
	shardBase := shard.shardBase

	for i, oldHash := range shard.cardHashes {
		// Shards can contain parts of more than one span
		// Shards can not contain parts of more than one arena.
		// Cards can not contain parts of more than one page or span.
		// Make sure this card is actually in a span that might hold
		// mature pointers.
		cardStart := shardBase + uintptr(i*cardBytes)
		if !inheap(cardStart) {
			continue
		}
		span := spanOf(cardStart)
		if span.state.get() != mSpanInUse {
			continue // cards do not span spans so entire card is in this span.
		}

		if cardStart < span.base() || cardStart > span.limit {
			// This is an indication that we have a span that
			// has an inconsistant (or at least not understood)
			// state. It is mSpanInUse, and it is in the inheap but
			// clearly the address we used to reach the span
			// structure got us to the wrong structure.
			println("runtime: span.state=", mSpanStateNames[span.state.get()],
				" cardStart (", cardStart, ") < span.base() (", span.base(), ") || cardStart > span.limit (", span.limit, ")")
			throw("inconsistant span metadata")
		}
		if span.gcmarkBits == nil {
			// This is a benign race condition caused by a span
			// being initialized or merged with another unused span.
			// If this span doesn't have any mark bits then
			// it was created since the start of this GC cycle
			// and has no mature objects.
			// This seems a bit hacky, like if it doesn't have
			// any mark bits how do we mark objects in it as
			// reachable. We know the state is _MSpanInUse
			// from above. There is a brief moment during
			// the creation of the span that the state is set
			// to _MSpanInUse and then immediately freed.
			continue
		}
		if span.spanclass.noscan() {
			continue
		}
		if span.nelems == 0 {
			// span has no elements in it. This can happen
			// during initialization, see grow().
			continue
		}

		cardEnd := cardStart + cardBytes
		hash := span.hashMatureCard(cardStart, cardEnd) // Expensive since it recalculates the arena.
		if hash != oldHash {
			span.promoteMatureCardPtrs(cardStart, cardEnd)
			shard.cardHashes[i] = hash
		}
	}
}

func initCardShardBase(ha *heapArena, base uintptr) {
	for i := 0; i < len(ha.cardShards); i++ {
		ha.cardShards[i].shardBase = base + uintptr(cardShardBytes*i)
	}
}

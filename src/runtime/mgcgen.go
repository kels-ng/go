// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

// Generational GC
//
// Go uses a sticky bit approach to implement generational
// GC. (See Alan Demers, Mark Weiser, Barry Hayes,
// Hans Boehm, Daniel Bobrow, and Scott Shenker. 1989.
// Combining generational and conservative garbage
// collection: framework and implementations. In
// Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on
// Principles of programming languages (POPL '90). ACM,
// New York, NY, USA, 261-269.
// DOI=http://dx.doi.org/10.1145/96709.96735 for the
// original reference.)
//
// Instead of "card marking" Go uses "card hashing" to
// identify regions that may contain pointers from
// mature to young objects. This approach has the advantage
// of eliminating the write barrier typically used to
// monitor the installation of mature to young pointers.
//
// Like similar systems we divide the heap into cards. Each
// card is a fixed number of bytes and given a heap address
// one can generate an index into a card table. Likewise an
// index in the card table can be used to locate the base
// of the card in the heap.
//
// Traditional card table entries hold a "mark". If
// a card is marked then it is possible that there is a
// pointer from a mature object to a young object in the
// card and the card must be scanned to locate and process
// such pointers. If unmarked no processing is required since
// the card is known not to contain a mature to young pointer.
//
// Traditional cards are marked by a write barrier that
// is invoked whenever a pointer is written into a card.
// The exact details are implementation specific but
// these classic mechanisms all use a write barrier of some
// sort.
//
// Go's card table entries hold a hash for each card.
// This hash is created by hashing all the heap pointers in
// the card. If a rehashing of the card produces the
// same hash then the card is considered unchanged.
// If on the other hand the hash changes from one GC cycle
// to the next cycle then the card is considered changed.
// The main advantage of this approach is that it does
// not need a write barrier so applications that do not
// benefit from a generation GC avoid the write barrier
// tax. For example applications that do few allocations
// and thus perform few  if any GCs can have a GC overhead
// that is much less than the overhead of a write barrier.
//
// The actual generational algorithm uses a traditional
// sticky bit approach as mentioned above. If the mark bit
// from the previous GC cycle is set the object survived the
// previous GC cycle and is considered mature. To
// promote an object one simply sets its mark bit.
//

const (
	gcGen      = true  // gcGen enables generational GC
	gcGenDebug = false // dump interesting debug information
)

// The hash generated by AES hash functions.
// 64 bits seems sufficient for our purposes here. However if there is a
// collision it could result in a reachable object being collected followed
// by undefined behavior.
// If further investigations suggest that we needed 128 bits, cardHash as
// well as the hashing calls need to be adjusted.
//
// There isn't the birthday problem so the chances of a collision
// are 1 in 2**64.
//
// Mean time between failures or MTBF is the important metric
// here. If it is significantly greater than other causes for failure
// then the risk is acceptable.
//
// Let's consider some conservative bounds.
// Assume Intel produces 400 million (4e8) chips a year. Assume they
// all run a Go program with a 10 GByte heap with 1 KBytes
// cards or 10e7 cards. Assume these chips executes
// a GC every second for a year (3.16e7 sec/year). We end up with
// 4e8 chips * 10e7 hashes/GC * 1 GC/sec * 3.16e7 sec/year = 1.26e23 hashes/year
// With a 64-bit hash, we expect
// 1.26e23 / 1.84e+19 = 6.847e3 or 6847 collisions/year.
// So for the 400 million chips there are 6847 failures in a year. That is a
// mean time to failure of 4e8/6.847e3 or 58,419 years. Assuming this
// math is correct and the assumptions reasonable then 64 bits is sufficient.
type cardHash uint64

// gen stores all state and statistics for generational GC.
// Hide all the generational GC values behind a variable called gen.
// Documentation for the fields are in the instantiation below.
var gen = struct {
	hashCardSeed      cardHash
	cycleCount        uint32
	forceFullGC       bool
	useMemhash        bool
	gcGenStats        bool
	spaceFull         bool
	warmupCount       uint32
	countBased        bool
	countBasedGen     bool
	cycleModulus      uint32
	highCostThreshold int
	cycleStats        cardStats
	totalStats        cardStats
}{
	hashCardSeed: cardHash(0), // Initialized to a random value.
	cycleCount:   0,           // count of GC cycles
	forceFullGC:  true,        // Force this cycle to do a full GC
	useMemhash:   false,       // true for HW/OSes without HW hashing, false for AMD64
	gcGenStats:   false,       // For experimental purpose this generates heap stats
	// After a full GC GOGC determines how much space is available for allocation. One necessary
	// but not sufficient condition for a generational GC to run is if less than half that
	// space survived the last GC. gen.spaceFull indicates if that space has been filled with
	// objects that survived the last GC.
	spaceFull: false,
	// The first warmupCount GCs are always full GCs.
	// TODO(rlh): warmup needs to be based on increasing heap size with a high
	// mark/cons ratio. Using a naive count of 4 until this can be fixed.
	warmupCount: 4,
	// if countBased is true and countBasedGen is true we do a full
	// GC when count % cycleModulus is 0
	// if countBased is true and countBasedGen is false we do a
	// generational when count % cycleModulus is 0
	// Use counting as the heuristic to determine if the cycle is a full
	// or generational cycle.
	countBased:    true,
	countBasedGen: true,
	cycleModulus:  2,
	// Avoid generational GC if cost of a full GC, as reported by
	// memstats.gc_cpu_fraction is < highGCCostThreshold.
	// The value is given as an int percent.
	highCostThreshold: 10,

	// Statistics and interesting characterizations of the heap are kept
	// in cycle specific as well as totals. Typically these are reported
	// if debug.gctrace>0.
	cycleStats: cardStats{},
	totalStats: cardStats{},
}

// For experiments and collecting of heap characterizations record
// various interesting values in a per cycle as well as a total.
type cardStats struct {
	hashedMatureObjects  uintptr // mature objects involved in hash
	unhashedYoungObjects uintptr // young objects not involved in hash
	hashedMatureBytes    uintptr // mature objects involved in hash
	unhashedYoungBytes   uintptr // young objects not involved in hash
	hashedCardsDiffers   uintptr // number of hashed cards where hash differs
	hashedCardsNodiffs   uintptr // number of hashed cards where hashes don't differ
	hashedBytesMarked    uintptr // number of hashed bytes where hash differs
	hashedBytesUnmarked  uintptr // number of hashed bytes where hashes don't differ
	scanCards            uintptr
	noScanCards          uintptr
	pointerCount         uintptr
	matureToYoung        uintptr
	matureToNil          uintptr
	matureToMature       uintptr
	ignoredCards         uintptr
}

// cardShard holds the information related to a shard
// of cards. These are added to mheap.shardedCardTable under the
// mheap lock when a new arena is added.
// See mheap.shardedCardTable.
type cardShard struct {
	cardHashes [cardsPerShard]cardHash // The hashes in this shard.
	shardBase  uintptr                 // pointer to where in the heap the first card starts
}
